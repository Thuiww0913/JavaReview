# JavaReview01_Java基础语法：

*@author Thuiww*

*@date 2025-01-22*

***

## 一、预备知识Review：

### 1.1 什么是 JDK，JRE？

* **JDK** *(Java Development Kit)*：Java程序开发工具包
* **JRE** *(Java Runtime Environment)*：Java程序运行环境

### 1.2 各进制如何表示？

***<补充>：***这里的各进制的表示，指的是在编程中如何表示当前数字是多少进制

* 二进制：  
  由0，1组成。以 **`0b`** 开头*（注意是 数字0 而不是字母o）*  
  如：`0b110`， `0b110110`， ~~`0b112110`~~
* 八进制：  
  由0，1，2，3，4，5，6，7组成。以 **`0`** 开头*（注意是 数字0 而不是字母o）*  
  如：`0371`， `02651`， ~~`0128`~~
* 十六进制：  
  由0，1，......9，a,b,c,d,e,f(大小写均可)组成。以 **`0x`** 开头*（注意是 数字0 而不是字母o）*  
  如：`0x5A29`， `0XABC`， `0x89AF`
* 十进制：  
  由0，1......,9组成。默认整数。

### 1.3 什么是字符集与编码？

**字符集：**

字符集是**一组字符的集合**，通常包括字母、数字、符号和特殊字符等，用于表示书写系统中的所有可能字符。每一个字符都有相对应的字符集代码点

- 例子
  - **Unicode 字符集**：一个全球通用的字符集，包含几乎所有书写系统的字符。
  - **GBK 字符集**：一个针对简体中文的字符集，包含中文汉字、繁体汉字等，一些常用符号。

**编码：**

编码是**将字符集中的字符映射为二进制数据的规则或方法**，用于存储或传输字符。因为字符集只是单纯字符和字符集代码点*(码点)*的一一对应，其中并不包含这些代码点在计算机中如何存储，以及计算机该如何依次识别这些代码点。所以，编码由此诞生，编码是以相对应的字符集为基础，在字符集码点的基础上重新再定义编码的码点，然后定义这些编码码点占用几个字节（以便于计算机识别），即：计算机识别到这些编码码点时，该按照几个字节来依次读取

- 例子
  - **UTF-8、UTF-16、UTF-32**编码 是 Unicode 字符集的编码方式。
  - **GBK 编码** 是 GBK 字符集的编码方式。

### 1.4 Unicode字符集：

#### 1.4.1什么是Unicode字符集：

* **Unicode字符集**是一个用于表示世界上几乎所有书写系统的字符标准，支持 100 多种语言和符号，它的目标是为每个字符分配一个唯一的代码点，以实现跨平台、跨语言的统一编码和互操作性。
* **Unicode代码点书面表示：** **`U+`**是一种通用的表示方法（其后面跟的码点要以十六进制表示），用于描述Unicode 字符集中的码点。它仅仅是逻辑上的一种约定，不直接与存储或程序中的具体编码格式绑定。如：应用于文档、书籍、技术规范中表示Unicode码点。
  如：`U+0041` 表示字符 `A`；`U+6C49` 表示汉字 `汉`； `U+1F60A` 表示表情符号 😊。
* **编码空间（Code Space）**： Unicode 的编码空间范围是从 `U+0000` 到 `U+10FFFF`，理论上支持 111 万多个字符。（21位：`1 0000` `1111 1111` `1111 1111`）
* **未分配区域**：在 Unicode编码空间中（`u+0000`~`u+10FFFF`），也含有未分配码点区域，如：`U+D800` 至 `U+DBFF`， `U+DC00` 至 `U+DFFF`，这两个区域分别作为 utf-16编码的低位代理和高位代理，均不映射任何字符；除此之外其中还有很多未分配区域，专门用于表示其他的一些含义
* **常见字符**：一些常见的字符和语言（英语、汉语、韩语、拉丁语，等）均在前16位之前（`u+FFFF`之前）完成相应的映射，而对于 `u+10000`~`u+10FFFF`所映射的字符，均为语言中一些不常用字符，其中也包含一些表情符号，如：𪛖`U+2A6D6`，😊`U+1F60A`

#### 1.4.2 Unicode字符集对应三种编码：

* **utf-8：**
  * ***概述***：变长编码*（1~4 个字节表示）*，每个字节的高位用于标识字节的数量和字符的范围，使得计算机可以依次识别。为了兼容ASCII，其中，ASCII（`U+0000` 至 `U+007F`）用一个字节表示，两个字节一般表示拉丁文等等，三个字节一般表示中文、韩文、日文等等，四个字节一般表示各种生僻字、特殊符合和表情等等。
  * ***编码规则***：
    * **1 字节**：字节的最高位为 `0`，二进制表示：`0xxx xxxx`  
      后面依次对应：码点 `U+0000` 到 `U+007F`的字符，占据7位
    * **2 字节**：字节的最高 3 位为 `110`，第二字节的最高 2 位为 `10`。二进制表示：`110x xxxx` `10xx xxxx`  
      后面依次对应：码点  `U+0080` 到 `U+07FF `的字符，占据11位
    * **3 字节**：字节的最高 4 位为 `1110`，后两字节的最高 2 位为 `10`。二进制表示：`1110 xxxx` `10xx xxxx` `10xx xxxx`  
      后面依次对应：码点 `U+0800` 到 `U+FFFF`的字符，占据16位
    * **4 字节**：字节的最高 5 位为 `11110`，后面三个字节的最高 2 位为 `10`。二进制表示：`1111 0xxx` `10xx xxxx` `10xx xxxx` `10xx xxxx`  
      后面依次对应：码点 `U+10000` 到 `U+10FFFF`的字符，占据21位
  * ***示例：***
    * `A`：Unicode 码点 `U+0041`（二进制<small>(属于1 字节->7位)</small>：`100 0001`）：  
      **UTF-8 编码**：`41`（1 字节 8位：<u>**0**100 0001</u>）
    * `汉`：Unicode 码点 `U+6C49`（二进制<small>(属于3 字节->16位)</small>：`0110 1100` `0100 1001`）：  
      **UTF-8 编码**：`E6 B1 89`（3字节 24位：<u>**1110** 0110</u> <u>**10**11 0001</u> <u>**10**00 1001</u>）
    * `😊`：Unicode 码点 `U+1F60A`（二进制<small>(属于4 字节->21位)</small>：`0 0001` `1111 0110` `0000 1010`）：  
      **UTF-8 编码**：`F0 9F 98 8A`（4字节 32位：<u>**1111 0**000</u> <u>**10**01 1111</u> <u>**10**01 1000</u> <u>**10**00 1010</u>）

* **utf-16：**
  * ***概述***：变长编码*（2 或 4 个字节表示）*  
    * 对于 **BMP 字符（基本多文种平面）**（Unicode：`U+0000` 到 `U+FFFF`），UTF-16 使用 **2 字节**表示，与 Unicode字符集一一映射，两字节中前面空余位数补零
    * 对于 **增补字符**（`U+10000` 到 `U+10FFFF`），UTF-16 使用 **代理对（2 个 16 位单元）**来表示，即使用 4 个字节。即，最终得出的utf-16编码会落于：高位代理：`U+D800` 至 `U+DBFF`， 低位代理：`U+DC00` 至 `U+DFFF`，这两个区间段，高位加低位共32位（四字节）组成一个utf-16编码，计算机通过识别第一个字符如果落于`U+D800` 至 `U+DBFF`则说明这是增补字符，将一次性读取四个字节，继而判断后两个字节是否落于`U+DC00` 至 `U+DFFF`字段，如果是则显示增补字段，若不是则报错编码异常。如果一开扫描两个字节不处于`U+D800` 至 `U+DBFF`，则说明是BMP字符，即正常显示这两个字节映射的字符即可。
    
  * ***编码规则***：
  
    * **2 字节**：将 Unicode字符集码点前16位范围内的字符直接一一映射于两字节中，前面空余位数补零  
      对应Unicode码点范围：`u+0000`到 `u+FFFF`
  
    * **4 字节**：将 Unicode字符集码点16位到21位范围内的字符，经拆分并进行相应运算，分为高16位和低16位，将高、低一一映射到四个字节中  
      对应Unicode码点范围：`u+FFFF`到 `u+10FFFF `  
      <补充>:经过拆分和运算得到的高位范围必在：`U+DC00` 至 `U+DFFF` 之间，低位范围必在：`U+DC00` 至 `U+DFFF`之间  
  
  * ***示例：***
  
    * `A`：Unicode 码点 `U+0041`：  
      **UTF-16 编码**：`0041`（2字节）
    * `汉`：Unicode 码点 `U+6C49`：  
      **UTF-16 编码**：`6C49`（2字节）
    * `😊`：Unicode 码点 `U+1F60A`：  
      **UTF-16 编码**：`D83D DE0A`（4字节）
* **utf-32：**
  * ***概述***：定长编码*（4 个字节表示）*，将 Unicode字符集码点范围内的字符（0~21位）直接一一映射于四字节中，前面空余位数补零。无论字符的 Unicode 码点范围如何，UTF-32 总是使用 4 个字节来表示字符。

  * ***编码规则***：
    * **4 字节**：直接使用 4 字节存储 Unicode 码点的二进制表示。空位补零

  * ***示例：***

    * `A`：Unicode 码点 `U+0041`：  
      **UTF-32 编码**：`00000041`（4 字节）
    * `汉`：Unicode 码点 `U+6C49`：  
      **UTF-32 编码**：`00006C49`（4 字节）
    * `😊`：Unicode 码点 `U+1F60A`：  
      **UTF-32 编码**：`0001F60A`（4 字节）

**对比总结：**

| **字符** | **Unicode 码点** | **UTF-8**              | **UTF-16**           | **UTF-32**          |
| -------- | ---------------- | ---------------------- | -------------------- | ------------------- |
| `A`      | `U+0041`         | `41` (1 字节)          | `0041` (2 字节)      | `00000041` (4 字节) |
| `汉`     | `U+6C49`         | `E6 B1 89` (3 字节)    | `6C49` (2 字节)      | `00006C49` (4 字节) |
| `😊`      | `U+1F60A`        | `F0 9F 98 8A` (4 字节) | `D83D DE0A` (4 字节) | `0001F60A` (4 字节) |

#### 1.4.3 代码中通过 utf-8/16/32 码点映射字符：

**使用转义字符：`\u`**

- **`\u`** 是一种在编程语言中使用的转义序列，用于在源代码中表示 基于Unicode 字符集编码的码点（utf-8/16/32）。
- 适用场景：**Java、JavaScript、C#、Python 等编程语言**，用于在 `字符串`或`字符`中插入 Unicode 字符。

<mark>**<注意>：**</mark>使用 `\u` 转义字符时，必须了解编程语言的内部字符编码方式，以及它如何解析 `\u` 后的字符。这是因为不同的语言和其所使用的编码方式会直接影响转义字符的解析和存储。如：

* **Java**内部字符编码采用 utf-16编码，当需要通过转义字符 `\u`来表示某一个属于unicode字符集中字符时，必须满足 utf-16代码点，如：`😊`UTF-16 编码：`D83D DE0A`（四个字节），即`\uD83D\uDE0A`
* **C/C++**其内部字符编码基于实现，若是基于utf-32实现，那么使用转义字符输出`😊`表情，可以使用`\U`（后接8位16进制），UTF-32 编码：`0001F600`（四个字节），即`\U0001F600`

**字符规则**：

* `\u` 转义字符的使用**仅限于基于 Unicode 字符集的编码**，

- `\u` 后面必须紧跟 4 位 16 进制数字，如：
  - `\u0041` 表示字符 `A`。
  - `\u6C49` 表示汉字 `汉`。
- 如果需要表示超出 4 位的 Unicode 码点（例如 `U+1F60A`），需要使用特殊的表示方式：
  - 在 Java（utf-16）
    - 使用 **代理对**（Surrogate Pair）：`"\uD83D\uDE0A"`。
  - 在 C/C++（utf-8/16/32）
    - 使用扩展形式：`"\U0001F60A"`。

**示例：**

```java
//Java示例（utf-16）
System.out.println('\u0041'); // 输出: A
System.out.println("\u6C49"); // 输出: 汉
System.out.println("\uD83D\uDE0A"); // 输出: 😊
```

```python
# Python 示例（utf-8/16/32）
print('\u0041')        # 输出: A
print('\u6C49')        # 输出: 汉
print('\U0001F60A')    # 输出: 😊
```

**对比 `u+` 和 `\u`:**

| **属性**         | **`U+`**                            | **`\u`**                              |
| ---------------- | ----------------------------------- | ------------------------------------- |
| **使用场景**     | 描述 Unicode 码点（逻辑概念）       | 编程语言中的 基于Unicode编码的 序列   |
| **表示内容**     | 一个逻辑码点，用于标识 Unicode 字符 | 用于在代码中嵌入字符（需转义）        |
| **语法要求**     | `U+` 后接码点（十六进制数字）       | `\u` 后必须跟 4 位十六进制数字        |
| **扩展字符表示** | 不需要额外处理，直接表示            | 需要代理对或扩展语法来支持 4 字节字符 |

### 1.5 其他字符集：

#### 1.5.1 GBK字符集：

**GBK字符集：**  

* **GBK字符集：** 是中国国家标准编码，它既可以看作一种字符集，也可以看作一种编码方案，但这取决于具体语境。GBK 是对 GB2312（1980年发布）的扩展。其扩展了繁体字、少数民族文字或更多国际字符*（常用的日文、韩文、拉丁文等）*，总计字符数约 **21,886** 个字符（15位）
  * **GB2312部分**：收录了6,763个字符（包括汉字和其他符号）。
  * **扩展部分**：收录了15,123个字符，主要包括汉字、日文假名、韩文字符和其他特殊符号。
* **GBK编码**：变长编码*（1 或 2 个字节表示）*，兼容ASCII且占据一个字节，当计算机识别首字节第一位为 0 时，则默认将第一个字节作为单独一个字符来识别，从而识别ASCII字符，当首字节第一位不为 0 时，继而再继续识别第二个字节，将第一个字节和第二字节一并识别为一个字符，从而识别除ASCII字符以外的其他字符（如：中文，等）
  * **1 字节**：对应 **ASCII字符集** 的内容（00 ~ 7F），与ASCII完全兼容
  * **2 字节**：用于表示中文汉字和扩展字符。范围是81至 FE（第一个字节）和 40 至 FE（第二个字节）
* **示例：**
  * **单字节字符**：41（对应字符 `'A'`）
  * **双字节字符**：B0A1（对应中文 `'啊'`）


#### 1.5.2 Latin-1（ISO 8859-1）字符集：

**Latin-1字符集：**

- **Latin-1字符集：** 是欧洲常用的一种字符集，又称为 **Latin Alphabet No.1**，主要覆盖西欧语言的字符。于1987年发布，广泛用于早期计算机系统中。每个字符占用1个字节，便于处理和存储。仅支持西欧语言，无法表示东欧、中文、日文等复杂语言字符。
  - **支持语言**：拉丁语系语言（如英语、法语、德语、西班牙语、葡萄牙语、意大利语等）。
  - **字符总数**：**256个字符**（8位），其中前128个字符与ASCII完全一致，后128个字符扩展了西欧语言中的特殊符号和字母（如带重音符号的字母：é、ä、ø等）。
  - **后续扩展：** 为了支持更多语言，ISO 8859 系列还推出了其他版本，如ISO 8859-2（东欧语言）、ISO 8859-3（南欧语言）等。

**Latin-1编码：** 定长编码（**1个字节**），字节范围为 **00 ~ FF**。

- **前128个字符（00 ~ 7F）**：与ASCII字符集完全一致，表示标准的英文字母、数字和常用符号。
- **后128个字符（80 ~ FF）**：扩展字符，用于表示西欧语言的特殊字符（如é、ç、ñ等）以及控制字符。

**示例：**

- 单字节字符：
  - 0x41（ASCII 'A'）
  - 0xC9（拉丁字母 'É'）
- **不可用的字符：** 超出范围的字符（如中文‘你’）无法在Latin-1中表示。

#### 1.5.3 <补充> 什么是ANSI编码 ？

**ANSI编码：**

* **ANSI编码并不是单一的字符集或编码标准**，而是一个广义术语，用于表示微软在Windows系统中使用的本地化编码方案。也就是说ANSI编码是一个代指编码，指的是当前Windows使用的某种编码，统一代称为ANSI编码。其根据当前Windows使用的时区地区的不同从而使用不同的字符集编码（ISO 8859-1、GBK、Shift-JIS， 等等）

* **ANSI编码的代码页**：
  ANSI编码采用代码页（Code Page）的方式，根据时区地区从而选择不同的字符集。例如：

  - **代码页 1252（Western European）：** 西欧语言（基于ISO 8859-1）（美国、英国等国家也是用）。
  - **代码页 936（GBK）：** 用于简体中文，兼容GB2312和部分GBK扩展字符。
  - **代码页 932（Shift-JIS）：** 用于日语。
  - **代码页 1251（Cyrillic）：** 用于俄语等斯拉夫语言。

  所以，ANSI是一种泛指的编码方案，其编码类型依赖于代码页，代码页原则依据与当前Windows时区设置，可以通过改变Windows时区从而决定ANSI编码的选择。

* **Windows区域设置与ANSI编码的关系：**

  | **区域**         | **语言**     | **ANSI代码页** | **编码特点**                    |
  | ---------------- | ------------ | -------------- | ------------------------------- |
  | 中国（简体中文） | 中文（简体） | 936            | GBK（变长编码，1或2字节）       |
  | 日本             | 日文         | 932            | Shift-JIS（变长编码，1或2字节） |
  | 美国             | 英语（美国） | 1252           | Latin-1（单字节编码）           |
  | 俄罗斯           | 俄语         | 1251           | Cyrillic（单字节编码）          |

**软件如何处理ANSI编码：**

* **软件层面：（不正当的使用会产生乱码）**

  - 如果软件明确支持Unicode（如UTF-8），则不会受到ANSI默认编码的影响，能够正确处理国际化文本（由自身解码）。
  - 如果软件只支持ANSI，那么它会默认按当前系统的代码页来解码内容。  
    如：如果将时区设置成美国（代码页 1252：ISO 8859-1），则当前系统中如果有部分软件只支持ANSI（如：VC++6.0）则，这些软件系统本身中的中文字符就会乱码。如：软件系统中的中文字符：`菜单`（GBK编码：`B2CB` `B5A5`）会被解码成`²Ëµ¥`（ISO依次解码`B2` `CB` `B5` `A5`）；
    - **`B2`**：在代码页 1252 中对应的字符是 `²`（上标 2）。
    - **`CB`**：对应的字符是 `Ë`（拉丁字母 E 带两个点）。
    - **`B5`**：对应的字符是 `µ`（希腊字母 μ 或表示微米）。
    - **`A5`**：对应的字符是 `¥`（日元符号）。

  当下大部分软件都支持Unicode自身解码，通常自带解码器，自行处理文本解码，而不是依赖操作系统的默认ANSI设置，能正确处理跨语言、跨区域的文本。但是对于部分老旧软件就不太支持自身解码采用默认 ANSI解码。  
  如：

  * CMD（命令提示符）：默认使用ANSI（代码页）解码，受系统区域设置影响。
  * VC++6.0：默认ANSI解码，受系统区域设置影响
  * PowerShell：支持UTF-8等多种编码格式，支持更好的跨语言兼容。























